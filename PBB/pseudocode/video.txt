class Video
Private
    LPDIRECTDRAW7 lpDD := NULL
    LPDIRECTDRAWSURFACE7 lpDDSPrimarySurface := NULL
    LPDIRECTDRAWSURFACE7 lpDDSSecondarySurface := NULL
    LPDIRECTDRAWCLIPPER lpDDClipper := NULL
    uint colourKey 

    function uint RGBTo32Bit(uint a, uint r, uint g, uint b) : inline, static
            return ((b) + ((g) << 8) + ((r) << 16) + ((a) << 24))
    end function

    function void AttachClipper(HWND hWnd) : static
        
        result := lpDD->CreateClipper()
        if (result != DD_OK)
            switch(result)
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("CreateClipper: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("CreateClipper: one or more of the parameters passed to the method are incorrect.")

                DDERR_NOCOOPERATIVELEVELSET:
                    throw DirectDrawNoCooperativeLevelSetException("CreateClipper: attempting to attach a clipper without first setting the cooperative level.")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemoryException("CreateClipper: not enough memory available to complete the operation.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::CreateClipper failed.", result)
            end switch
        end if

        result := lpDDClipper->SetHWnd(0, hWnd)
        if(result != DD_OK)
            switch(result)
                DDERR_INVALIDCLIPLIST:
                    throw DirectDrawInvalidClipListException("SetHWnd: DirectDraw doesn't support the provided clip list.")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("SetHWnd: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("SetHWnd: One or more of the parameters passed to the method are incorrect.")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemory("SetHWnd: not enough memory to complete the operation.")
                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawClipper::SetHWnd failed.", result)
            end switch
                
        end if

        result := lpDDSSecondarySurface->SetClipper(lpDDClipper)
        if(result != DD_OK)
            switch(result)
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("SetClipper: DirectDraw doesn't support the provided clip list.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("SetClipper: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDSURFACETYPE:
                    throw DirectDrawInvalidSurfaceTypeException("SetClipper: the requested operation could not be performed because the surface was of the wrong type.")

                DDERR_NOCLIPPERATTACHED
                    throw DirectDrawNoClipperAttachedException("SetClipper: No DirectDrawClipper object is attached to the surface object.")
                
                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::SetClipper failed.", result)
            end switch
        end if
    end function

    function void CreateFullscreenWindow(HWND hWnd, uint width, uint height, uint bitsPerPixel) : static 

        VerifyNotNull(lpDD)
        result := lpDD->SetCooperativeLevel(hWnd, DDSCL_FULLSCREEN | DDSCL_EXCLUSIVE | DDSCL_ALLOWREBOOT)
        if(result != DD_OK)
            switch(result)    
                DDERR_EXCLUSIVEMODEALREADYSET:
                    throw DirectDrawExclusiveModeAlreadySetException("SetCooperativeLevel: an attempt was made to set the cooperative level when it was already set to exclusive.")
                DDERR_HWNDALREADYSET:
                    throw DirectDrawHWNDAlreadySetException("SetCooperativeLevel: the window handle has already been set. It cannot be reset while the process has surfaces or palettes created.")
                DDERR_HWNDSUBCLASSED:
                    throw DirectDrawHWNDSubclassedException("SetCooperativeLevel: the window handle has been subclassed.")
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("SetCooperativelevel: DirectDraw received a pointer that was an invalid DirectDraw object.")
                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("SetCooperativeLevel: one or more of the parameters passed to the method are incorrect.")
                DDERR_OUTOFMEMORY:
                    throw new System::OutOfMemoryException("SetCooperativeLevel: Not enough memory available to complete the operation.")
                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::SetCooperativeLevel failed.", result)
            end switch
        end if

        result := lpDD->SetDisplayMode(width, height, bitsPerPixel, 0, 0);
        if(result != DD_OK)
            switch(result)
                DDERR_GENERIC:
                    throw DirectDrawGenericException("SetDisplayMode: undefined error condition, so that's cool.")

                DDERR_INVALIDMODE:
                    throw DirectDrawInvalidModeException("SetDisplayMode: the requested mode is unsupported.")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("SetDisplayMode: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("SetDisplayMode: one or more of the parameters passed to the method are incorrect.")

                DDERR_LOCKEDSURFACES:
                    throw DirectDrawLockedSurfaceException("SetDisplayMode: one or more surfaces are locked, causing the failure of the requested operation.")

                DDERR_NOEXCLUSIVEMODE:
                    throw DirectDrawNoExclusiveModeException("SetDisplayMode: exclusive mode required to complete the operation.")

                DDERR_SURFACEBUSY:
                    throw DirectDrawSurfaceBusyException("SetDisplayMode: access to the surface is refused because the surface is locked by another thread.")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("SetDisplayMode: the operation is not supported.")

                DDERR_UNSUPPORTEDMODE:
                    throw DirectDrawUnsupportedModeException("SetDisplayMode: the display is currently in an unsupported mode.")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("SetDisplayMode: the previous blit operation that is transferring information to or from this surface is incomplete.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::SetDisplayMode failed.\n", result)
            end switch
        end if

        DDSURFACEDESC2 ddSD
        SecureZeroMemory(ddSD, sizeof(ddSD))

        ddSD.dwFlags := DDSD_CAPS | DDSD_BACKBUFFERCOUNT
        ddSD.ddsCaps.dwCaps := DDSDCAPS_PRIMARYSURFACE | DDSCAPS_COMPLEX | DDSCAPS_FLIP
        ddSD.dwBackBufferCount := 1

        result := lpDD->CreateSurface()
        if (result != DD_OK)
            switch(result)
                DDERR_INCOMPATIBLEPRIMARY:
                    throw DirectDrawIncompatiblePrimarySurfaceException("CreateSurface: the primary surface creation request does not match the existing primary surface. ")

                DDERR_INVALIDCAPS:
                    throw DirectDrawInvalidCapsException("CreateSurface: one or more of the capability bits is incorrect.")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectExeption("CreateSurface: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("CreateSurface: one or more of the parameters passed to the method are incorrect.")

                DDERR_INVALIDPIXELFORMAT:
                    throw DirectDrawInvalidPixelFormatException("CreateSurface: an invalid pixel format was specified.")

                DDERR_NOALPHAHW:
                    throw DirectDrawNoAlphaHardwareException("CreateSurface: the video device doesn't support alpha hardware acceleration or it's unavailable.")

                DDERR_NOCOOPERATIVELEVELSET:
                    throw DirectDrawNoCooperativeLevelSetException("CreateSurface: attempting to create a surface without first setting the cooperative level.")

                DDERR_NODIRECTDRAWHW:
                    throw DirectDrawNoDirectDrawHardwareException("CreateSurface: the current device doesn't support hardware-only DirectDraw acceleration.")

                DDERR_NOEMULATION:
                    throw DirectDrawNoEmulationException("CreateSurface: software emulation isn't available.")

                DDERR_NOEXCLUSIVEMODE:
                    throw DirectDrawNoExclusiveModeException("CreateSurface: exclusive mode required to complete the operation.")

                DDERR_NOFLIPHW:
                    throw DirectDrawNoFlipHardwareException("CreateSurface: flipping visible surfaces is not supported by the video hardware.")

                DDERR_NOMIPMAPHW:
                    throw DirectDrawNoMipMapHardwareException("CreateSurface: unable to complete the operation because mipmapping isn't supported by the hardware or is not available.")

                DDERR_NOOVERLAYHW:
                    throw DirectDrawNoOverlayHardwareException("CreateSurface: unable to complete the operation because no hardware support for overlay is available.")

                DDERR_NOZBUFFERHW:
                    throw DirectDrawNoZBufferHardwareException("CreateSurface: unable to complete the operation because no hardware support for Z-ordering overlays is available")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemoryException("CreateSurface: DirectDraw does not have enough memory to perform the operation.")

                DDERR_OUTOFVIDEOMEMORY:
                    throw DirectDrawOutOfVideoMemoryException("CreateSurface: DirectDraw does not have enough display memory to perform the operation.")

                DDERR_PRIMARYSURFACEALREADYEXISTS:
                    throw DirectDrawPrimarySurfaceAlreadyExistsException("CreateSurface: a primary surface already exists.")

                DDERR_UNSUPPORTEDMODE:
                    throw DirectDrawUnsupportedModeException("CreateSurface: unable to create a surface for the current display mode, it's unsupported.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::CreateSurface failed.", result)
            end switch
        end if

        ddSD.ddSDCaps.dwCaps := DDSCAPS_BACKBUFFER

        result := lpDDSPrimarySurface->GetAttachedSurface(&ddSD.ddSCaps, &lpDDSBack)
        if(result != DD_OK)
            switch(result)
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("GetAttachedSurface: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("GetAttachedSurface: one or more of the parameters passed to the method are incorrect.")

                DDERR_NOTFOUND:
                    throw DirectDrawNotFoundException("GetAttachedSurface: the requested item was not found.")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostExeption("GetAttachedSurface: access to the surface is refused because the surface memory is gone. Call IDirectDrawSurfacce7::Restore() on this surface to restore the memory associated with it.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::GetAttachedSurface failed.", result)
            end switch
        end if

        try
            AttachClipper(hWnd)
        catch
            throw
        end try-catch
    end function
    
    function Surface CreateSurface(HBITMAP hBitmap)

        HDC hDCImage
        HDC hDC
        BITMAP bitmap
        LPDIRECTDRAWSURFACE7 lpDDSurface := NULL
        DDSURFACEDESC2 ddSD

        if(NULL = hBitmap)
            throw System::ArugmentNullException("CreateSurface: hBitmap is NULL when it shouldn't be.")
        end if


        -- retrieve needed information about the bitmap; needed to create the surface
        GetObject(hBitmap, sizeof(bitmap), &bitmap)

        SecureZeroMemory(&ddSD, sizeof(ddSD))
        ddSD.dwSize := sizeof(imageddsd)
        ddSD.dwFlags := DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_CKSRCBLT
        ddSD.ddsCaps.dwCaps := DDSCAPS_OFFSCREENPLAIN
        ddSD.dwWidth := bitmap.Width
        ddSD.dwHeight := bitmap.Height
        ddSD.ddckCKSrcBlt.dwColorSpaceLowValue = self->colourKey
        ddSD.ddckCKSrcBlt.dwColorSpaceHighValue = self->colourKey

        VerifyNotNull(lpDD)
        result := lpDD->CreateSurface(&ddSD, &lpDDSurface, NULL)
        if(result != DD_OK)
            switch(result)
                DDERR_INCOMPATIBLEPRIMARY:
                    throw DirectDrawIncompatiblePrimarySurfaceException("CreateSurface: the primary surface creation request does not match the existing primary surface. ")

                DDERR_INVALIDCAPS:
                    throw DirectDrawInvalidCapsException("CreateSurface: one or more of the capability bits is incorrect.")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectExeption("CreateSurface: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("CreateSurface: one or more of the parameters passed to the method are incorrect.")

                DDERR_INVALIDPIXELFORMAT:
                    throw DirectDrawInvalidPixelFormatException("CreateSurface: an invalid pixel format was specified.")

                DDERR_NOALPHAHW:
                    throw DirectDrawNoAlphaHardwareException("CreateSurface: the video device doesn't support alpha hardware acceleration or it's unavailable.")

                DDERR_NOCOOPERATIVELEVELSET:
                    throw DirectDrawNoCooperativeLevelSetException("CreateSurface: attempting to create a surface without first setting the cooperative level.")

                DDERR_NODIRECTDRAWHW:
                    throw DirectDrawNoDirectDrawHardwareException("CreateSurface: the current device doesn't support hardware-only DirectDraw acceleration.")

                DDERR_NOEMULATION:
                    throw DirectDrawNoEmulationException("CreateSurface: software emulation isn't available.")

                DDERR_NOEXCLUSIVEMODE:
                    throw DirectDrawNoExclusiveModeException("CreateSurface: exclusive mode required to complete the operation.")

                DDERR_NOFLIPHW:
                    throw DirectDrawNoFlipHardwareException("CreateSurface: flipping visible surfaces is not supported by the video hardware.")

                DDERR_NOMIPMAPHW:
                    throw DirectDrawNoMipMapHardwareException("CreateSurface: unable to complete the operation because mipmapping isn't supported by the hardware or is not available.")

                DDERR_NOOVERLAYHW:
                    throw DirectDrawNoOverlayHardwareException("CreateSurface: unable to complete the operation because no hardware support for overlay is available.")

                DDERR_NOZBUFFERHW:
                    throw DirectDrawNoZBufferHardwareException("CreateSurface: unable to complete the operation because no hardware support for Z-ordering overlays is available")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemoryException("CreateSurface: DirectDraw does not have enough memory to perform the operation.")

                DDERR_OUTOFVIDEOMEMORY:
                    throw DirectDrawOutOfVideoMemoryException("CreateSurface: DirectDraw does not have enough display memory to perform the operation.")

                DDERR_PRIMARYSURFACEALREADYEXISTS:
                    throw DirectDrawPrimarySurfaceAlreadyExistsException("CreateSurface: a primary surface already exists.")

                DDERR_UNSUPPORTEDMODE:
                    throw DirectDrawUnsupportedModeException("CreateSurface: unable to create a surface for the current display mode, it's unsupported.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::CreateSurface failed.", result)
            end switch
        end if

        DDCOLORKEY ddColourKey
        ddColourKey.dwColorSpaceHighValue = self->colourKey
        ddColourKey.dwColorSpaceLowValue = self->colourKey

        result := lpDDSurface->SetColorKey(DDCKEY_SRCBLT, &ddColourKey)))
        if(result != DD_OK)
            switch(result)
                DDERR_GENERIC:
                    throw DirectDrawGenericException("IDirectDrawSurface7::SetColorKey: ")
                
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_INVALIDSURFACETYPE:
                    throw DirectDrawInvalidSurfaceTypeException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_NOTAOVERLAYSURFACE:
                    throw DirectDrawNotAnOverlaySurfaceException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("IDirectDrawSurface7::SetColorKey: ")

                DDERR_WASSTILLDRAWING::
                    throw DirectDrawWasStillDrawingException("IDirectDrawSurface7:SetColorKey: ")
                default:
                     throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::SetColorKey failed.", result)
            end switch
        end if

        result := lpDDSurface->GetDC(&hDC)
        if(result != DD_OK)
            switch(result)
                DDERR_DCALREADYCREATED:
                    throw DirectDrawDCAlreadyCreatedException("GetDC: a device context has already been returned for this surface.")

                DDERR_GENERIC:
                    throw DirectDrawGenericException("GetDC: generic error occured, fucked if I know what's going on.")
                
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("GetDC: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("GetDC: one or more of the parameters passed to the method are incorrect.")

                DDERR_INVALIDSURFACETYPE:
                    throw DirectDrawInvalidSurfaceException("GetDC: the requested operation could not be performed because the surface was of the wrong type. ")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("GetDC: access to the surface is refused because the surface memory is gone. Call IDirectDrawSurface7::Restore to restore the memory associated with it.")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("GetDC: the operation is not supported.")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("GetDC: the previous blit operation is incomplete.")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::GetDC failed.", result)
            end switch
        end if

        hDCImage := CreateCompatibleDC(NULL)
        if(hDCImage == NULL)
            throw Win32Exception(Win32Exception::Format("CreateCompatibleDC"))
        end if

        SelectObject(hDCImage, hBitmap)

        if(BitBlt(hDC, 0, 0, bitmap.Width, bitmap.Height, hDCImage, 0, 0, SRCCOPY) == 0)
            throw Win32Exception(Win32Exception::FormatMessage("BitBlt"))
        end if
        lpDDSurface->ReleaseDC(hDC)

        DeleteObject(hDCImage)

        new Surface surface(lpDDSurface, bitmap.Width, bitmap.Height)
        return surface
    end function

    -- Clips the specified line if either of its points are located off screen, so Video::DrawLine() 
    -- doesn't attempt to access invalid regions of memory when drawing the line.
    -- Ecxeptions:
    -- System::ArgumentException: both lines From and To Points are the same, or
    --                            the function failed to clip the line due to a primordial flux in the 
    --                            hyperphonic modulator.
    function Line ClipLine(Line line, LPDDSURFACEDESC2 surfaceDescription)

        $define CLIPCODE_CENTER     0
        $define CLIPCODE_WEST       1
        $define CLIPCODE_EAST       2
        $define CLIPCODE_SOUTH      4
        $define CLIPCODE_SOUTHWEST  5
        $define CLIPCODE_SOUTHEAST  6
        $define CLIPCODE_NORTH      8
        $define CLIPCODE_NORTHWEST  9
        $define CLIPCODE_NORTHEAST 10
        
        new Rectangle clipRect(0, 0, surfaceDescription->dwWidth, surfaceDescription->dwHeight)

        int fromPointCode := 0
        int toPointCode := 0

        Point tempFromPoint := line->From;
        Point tempToPoin := line->To;

        if(line->From->Y < 0)
            fromPointCode |= CLIPCODE_NORTH
        else if(line->From->Y > clipRect->Height)
            fromPointCode |= CLIPCODE_SOUTH
        end if

        if(line->From->X < 0)
            fromPointCode |= CLIPCODE_WEST
        else if(line->From->X > clipRect->Width)
            fromPointCode |= CLIPCODE_EAST
        end if

        if(line->To->Y < 0)
            toPointCode |= CLIPCODE_NORTH
        else if(line->To->Y > clipRect->Height)
            toPointCode |= CLIPCODE_SOUTH
        end if

        if(line->To->X < 0)
            toPointCode |= CLIPCODE_WEST
        else if(line->To->X > clipRect->Width)
            toPointCode |= CLIPCODE_EAST
        end if

        
        if(fromPointCode & toPointCode)
            -- either both points match or the line is completely off screen.
            throw ArgumentException("both points match or the line is completely off screen."")
        else if(fromPointCode == 0 && toPointCode == 0)
            -- neither point is clipped by the bounding rect, so there's nothing more to do.
            return line
        end if

        -- determine the end clip point for the first point
        switch(fromPointCode)
            CLIPCODE_NORTH:
                tempFromPoint->Y := clipRect->Top
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Y - line->From->Y) * (line->To->X - line->From->X) / (line->To->Y - line->From->Y)
            
            CLIPCODE_SOUTH:
                tempFromPoint->Y := clipRect->Bottom
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Bottom - line->From->Y) * (line->To->X - line->From->X) / (line->To->Y - line->From->Y)
            
            CLIPCODE_WEST:
                tempFromPoint->X := clipRect->Left
                tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->Left - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X)
        

            CLIPCODE_EAST:
                tempFromPoint->X := clipRect->Right
                tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->Right - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X)

            -- these cases are more complex, must compute 2 intersections
            CLIPCODE_NORTHEAST:
                -- north hline intersection
                tempFromPoint->Y := clipRect->Y
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Y - line->From->Y)*(line->To->X - line->From->X) / (line->To->Y - line->From->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempFromPoint->X < clipRect->X || tempFromPoint->X > clipRect->Right)
                    -- east vline intersection
                    tempFromPoint->X := clipRect->Right
                    tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->Right - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X)
                end if 

            CLIPCODE_SOUTHEAST:
                -- south hline intersection
                tempFromPoint->Y := clipRect->Bottom;
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Bottom - line->From->Y)*(line->To->X - line->From->X) / (line->To->Y - line->From->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempFromPoint->X < clipRect->X || tempFromPoint->X > clipRect->Right)
                    -- east vline intersection
                    tempFromPoint->X := clipRect->Right
                    tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->Right - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X
                end if

            CLIPCODE_NORTHWEST:
                -- north hline intersection
                tempFromPoint->Y := clipRect->Y
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Y - line->From->Y)*(line->To->X - line->From->X) / (line->To->Y - line->From->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempFromPoint->X < clipRect->X || tempFromPoint->X > clipRect->Right)
                    tempFromPoint->X := clipRect->X
                    tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->X - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X)
                end if

            CLIPCODE_SOUTHWEST:
                -- south hline intersection
                tempFromPoint->Y := clipRect->Bottom
                tempFromPoint->X := line->From->X + 0.5 + (clipRect->Bottom - line->From->Y)*(line->To->X - line->From->X) / (line->To->Y - line->From->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempFromPoint->X < clipRect->X || tempFromPoint->X > clipRect->Right)
                    tempFromPoint->X := clipRect->X
                    tempFromPoint->Y := line->From->Y + 0.5 + (clipRect->X - line->From->X)*(line->To->Y - line->From->Y) / (line->To->X - line->From->X)
                end if

            default:
                break;
        end switch

        -- determine clip point for p2
        switch (toPointCode)
    
            CLIPCODE_NORTH:
                tempToPoint->Y := clipRect->Y
                tempToPoint->X := line->To->X + (clipRect->Y - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y)

            CLIPCODE_SOUTH:
                tempToPoint->Y := clipRect->Bottom
                tempToPoint->X := line->To->X + (clipRect->Bottom - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y)

            CLIPCODE_WEST:
                tempToPoint->X := clipRect->X
                tempToPoint->Y := line->To->Y + (clipRect->X - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)

            CLIPCODE_EAST:
                tempToPoint->X := clipRect->Right
                tempToPoint->Y := line->To->Y + (clipRect->Right - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)

            -- these cases are more complex, must compute 2 intersections
            CLIPCODE_NORTHEAST:
                -- north hline intersection
                tempToPoint->Y := clipRect->Y
                tempToPoint->X := line->To->X + 0.5 + (clipRect->Y - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y);

                -- test if intersection is valid, of so then done, else compute next
                if (tempToPoint->X < clipRect->X || tempToPoint->X > clipRect->Right)
                    -- east vline intersection
                    tempToPoint->X := clipRect->Right
                    tempToPoint->Y := line->To->Y + 0.5 + (clipRect->Right - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)
                end if

            CLIPCODE_SOUTHEAST:
                -- south hline intersection
                tempToPoint->Y := clipRect->Bottom
                tempToPoint->X := line->To->X + 0.5 + (clipRect->Bottom - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempToPoint->X < clipRect->X || tempToPoint->X > clipRect->Right)
                    -- east vline intersection
                    tempToPoint->X := clipRect->Right
                    tempToPoint->Y := line->To->Y + 0.5 + (clipRect->Right - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)
                end if

            CLIPCODE_NORTHWEST:
                -- north hline intersection
                tempToPoint->Y := clipRect->Y
                tempToPoint->X := line->To->X + 0.5 + (clipRect->Y - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempToPoint->X < clipRect->X || tempToPoint->X > clipRect->Right)
                    tempToPoint->X := clipRect->X
                    tempToPoint->Y := line->To->Y + 0.5 + (clipRect->X - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)
                end if

            CLIPCODE_SOUTHWEST:
                -- south hline intersection
                tempToPoint->Y := clipRect->Bottom
                tempToPoint->X := line->To->X + 0.5 + (clipRect->Bottom - line->To->Y)*(line->From->X - line->To->X) / (line->From->Y - line->To->Y)

                -- test if intersection is valid, of so then done, else compute next
                if (tempToPoint->X < clipRect->X || tempToPoint->X > clipRect->Right)
                    tempToPoint->X := clipRect->X
                    tempToPoint->Y := line->To->Y + 0.5 + (clipRect->X - line->To->X)*(line->From->Y - line->To->Y) / (line->From->X - line->To->X)
                end if
            default:
                break
        end switch

        -- verify they've been clipped. 
        if ((tempFromPoint->X < clipRect->X) || (tempFromPoint->X > clipRect->Right) ||
            (tempFromPoint->Y < clipRect->Y) || (tempFromPoint->Y > clipRect->Bottom) ||
            (tempToPoint->X < clipRect->X) || (tempToPoint->X > clipRect->Right) ||
            (tempToPoint->Y < clipRect->Y) || (tempToPoint->Y > clipRect->Bottom))
            // nope. 
            throw ArgumentException("Failed to clip the line, so have fun with that.")
        end if 

        return new Line(tempFromPoint, tempToPoint)
    end function

    -- Bresenham line algorithm
    function DrawLine(Line line, LPDDSURFACEDESC2 surfaceDescription)
       
        -- difference between both points on the X axis
        int deltaX

        -- difference between both points on the Y axis
        int deltaY

        int dx2
        int dy2

        -- the number of pixels to move along the X axis when drawing
        int xIncrementAmount 

        -- the number of pixels to move along the Y axis when drawing
        int yIncrementAmount

        int error

        UINT *video_buffer := (UINT *) surfaceDescription->lpSurface
        int pitch := surfaceDescription->lPitch >> 2

        deltaX := line->To->X - line->From->X
        deltaY := line->To->Y - line->From->Y

        -- test fo' the slopes angle, yo
        if(delta >= 0)
            xIncrementAmount := 1
        else
            xIncrementAmount := -1
            deltaX := -deltaX
        end if

        if(deltaY >= 0)
            yIncrementAmount := 1
        else 
            yIncrementAmount := -1
            deltaY := -deltaY
        end if

        int dx2 := deltaX << 1
        int dy2 := deltaY << 1

        int xCoordinate := line->From->X
        int yCoordinate := line->From->Y

        if(deltaX > deltaY)
            error := dy2 - deltaX

            for(i := 0; i <= deltaX; i++)
                uint colour := RGBTo32Bit(0, line->Colour->R, line->Colour->G, line->Colour->B)
                video_buffer[xCoordinate + yCoordinate * surfaceDescription->dwWidth] := colour

                if(error >= 0)
                    error -= dx2

                    yCoordinate += yIncrementAmount
                end if

                error += dy2

                xCoordinate += xIncrementAmount
            end for
        else
            error := dx2 - deltaY

            for(i := 0; i <= deltaY; i++)
                uint colour := RGBTo32Bit(0, line->Colour->R, line->Colour->G, line->Colour->B)
                video_buffer[xCoordinate + yCoordinate * surfaceDescription->dwWidth] := colour

                if(error >= 0)
                    error -= dy2
                    xCoordinate += xIncrementAmount
                end if

                error += dx2

                yCoordinate += yIncrementAmount
            end for
        end if
    end function
     
Public
    function void Initialise() : static
        colourKey := RGBTo32Bit(255, 255, 0, 255)

        result := DirectDrawCreateEx()
        if(result != DD_OK) 
            switch(result)
                DDER_INVALIDDIRECTDRAWGUID:
                    throw DirectDrawInvalidGUIDException("Invalid GUID passed to DirectDrawCreateEx")

                DDER_DIRECTDRAWALREADYCREATED:
                    throw DirectDrawAlreadyCreatedException("DirectDrawCreateEx: Direct Draw has already been initialised.")

                DDER_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("DirectDrawCreateEx: Invalid parameters passed to DirectDrawCreateEx")

                DDER_GENERIC:
                    throw DirectDrawGenericException("DirectDrawCreateEx: Undefined error condition returned by DirectDrawCreateEx. Consult your local psychic.")
            
                DDERR_NODIRECTDRAWHW:
                    throw DirectDrawNoHardwareException("DirectDrawCreateEx: The specified driver doesn't support DirectDraw hardware acceleration.")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemoryException("DirectDrawCreateEx: Not enough memory available to initialise DirectDraw.")
            
                default:
                    throw System::Runtime::InteropServices::COMException("DirectDrawCreateEx failed.", result)
            end switch
        end if
    end function

    function Clear(System::Drawing::Color ^colour)

        try
            Clear(colour->R, colour->G, colour->B)
        catch
            throw
        end try-catch

    end function

    function Clear(int r, int g, int b)

        DDBLTFX ddBltFX 

        SecureZeroMemory(&ddBltFX, sizeof(DDBLTFX))
        ddBltFX.dwFillColor := RGBTo32Bit(255, r, g, b)
        
        VerifyNotNull(lpDDSSecondarySurface)
        HRESULT result := lpDDSSecondarySurface->Blt(NULL, NULL, NULL, DDBLT_COLORFILL | DDBLT_WAIT, &ddBltFX)
        if(result != DD_OK)
            switch(result)
                DDERR_GENERIC:
                    throw DirectDrawGenericException("IDirectDrawSurface7::Blt: failed, fucked if I know why.")

                DDERR_INVALIDCLIPLIST:
                    throw DirectDrawInvalidClipListException("IDirectDrawSurface7::Blt: DirectDraw does not support the provided clip list.")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("IDirectDrawSurface7::Blt: DirectDraw received a pointer that was an invalid DirectDraw object.")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParameterException("IDirectDrawSurface7::Blt: one or more of the parameters passed to the method are incorrect.")

                DDERR_INVALIDRECT:
                    throw DirectDrawInvalidRectException("IDirectDrawSurface7::Blt: the provided rectangle was invalid.")

                DDERR_NOALPHAHW:
                    throw DirectDrawNoAlphaHardwareException("IDirectDrawSurface7::Blt: no alpha acceleration hardware is present or available.")

                DDERR_NOBLTHW:
                    throw DirectDrawNoBlitHardwareException("IDirectDrawSurface7::Blt: no blitter hardware is present.")

                DDERR_NOCLIPLIST:
                    throw DirectDrawNoClipListException("IDirectDrawSurface7::Blt: no clip list is available.")

                DDERR_NODDROPSHW:
                    throw DirectDrawNoDDRasterOperationHardwareException("IDirectDrawSurface7::Blt: no DirectDraw raster operation (ROP) hardware is available. ")

                DDERR_NOMIRRORHW:
                    throw DirectDrawNoMirrorHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no mirroring hardware is present or available. ")

                DDERR_NORASTEROPHW:
                    throw DirectDrawNoRasterOperationHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no appropriate raster operation hardware is present or available.")

                DDERR_NOROTATIONHW:
                    throw DirectDrawNoRotationHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no rotation hardware is present or available.")

                DDERR_NOSTRETCHHW:
                    throw DirectDrawNoStretchHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because there is no hardware support for stretching. ")

                DDERR_NOZBUFFERHW:
                    throw DirectDrawNoZBufferHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because there is no hardware support for Z-buffers.")

                DDERR_SURFACEBUSY:
                    throw DirectDrawSurfaceBusyException("IDirectDrawSurface7::Blt: access to the surface is refused because the surface is locked by another thread.")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("IDirectDrawSurface7::Blt: access to the surface is refused because the surface memory is gone. ")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("IDirectDrawSurface7::Blt: the operation is not supported. ")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("IDirectDrawSurface7::Blt: the previous blit operation that is transferring information to or from this surface is incomplete. ")

                default:
                   throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::Blt failed.", result)

            end switch
        end if
    end function

    function Surface CreateSurface(string path) : static

        HBITMAP hBitmap
      
        hBitmap := LoadImage(NULL, filename, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE)
        if(NULL = hBitmap)
            throw Win32Exception(Win32Exception::FormatMessage("LoadImage"))
        end if

       try
            return Video::CreateSurface(hBitmap)
       catch
            throw
       finally
            DeleteObject(hBitmap)
       end try-catch

    end function

    -- Draws one or more clipped lines using the Bresenham line algorithm.
    -- Exceptions: 
    -- System::ArgumentException: the coords of one of the lines in lines is invalid, or
    --                            lines is an empty array.
    -- System::ArgumentNullException: lines is NULL.
    function DrawLines(Line[] lines)
        if(lines = NULL)
            throw System::ArgumentNullException("lines is NULL")
        else if(lines->Count = 0)
            throw System::ArgumentException("lines is an empty array")
        end if

        DDSURFACEDESC2 ddSD
        SecureZeroMemory(&ddSD, sizeof(ddSD))
        ddSD.dwSize := sizeof(DDSURFACEDESC2)

        HRESULT result := lpDDSSecondarySurface->Lock(NULL, &ddSD, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL)
        if(result != DD_OK)
            switch(result)
                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("IDirectDrawSurface7::Lock: ")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("IDirectDrawSurface7::Lock: ")

                DDERR_OUTOFMEMORY:
                    throw System::OutOfMemoryException("IDirectDrawSurface7::Lock: ")

                DDERR_SURFACEBUSY:
                    throw DirectDrawSurfaceBusyException("IDirectDrawSurface7::Lock: ")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("IDirectDrawSurface7::Lock: ")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("IDirectDrawSurface7::Lock: ")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::Lock failed, yo!")
            end switch
        else

            for(i := 0 to lines->Count)
                try
                    Line clippedLine := self->ClipLine(line, ddSD)
                    self->DrawLine(line, ddSD)
                catch
                    throw
                end try
            end for

    end function

    function void Flip()
        -- DDFLIP_WAIT ensures it'll keep trying to flip until successful if the HAL returns
        -- DDERR_WASSTILLDRAWING
        HRESULT result := lpDDSPrimarySurface->Flip(NULL, DDFLIP_WAIT)
        if(result != DD_OK)
            switch(result)
                DDERR_GENERIC:
                    throw DirectDrawGenericException("")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("")

                DDERR_NOFLIPHW:
                    throw DirectDrawNoFlipHardwareException("")

                DDERR_NOTFLIPPABLE:
                    throw DirectDrawNotFlippableException("")

                DDERR_SURFACEBUSY:
                    throw DirectDrawSurfaceBusyException("")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::Flip() failed.\n")
            end switch
        end if
    end function

    function void Render(int x, int y, Surface surface)
        RECT destRect
        RECT srcRect

        destRect.left := x
        destRect.top := y
        destRect.bottom := surface->Height
        destRect.right := surface->Width

        srcRect.left := 0
        srcRect.top := 0
        srcRect.bottom := surface->Height
        srcRect.right := surface->Width

        HRESULT result := lpDDSSecondarySurface->Blt(&destRect, surface->Data, &srcRect, DDBLT_WAIT | DDBLT_KEYSRC, NULL)
        if(result != DD_OK)
            switch(result)
                DDERR_GENERIC:
                    throw DirectDrawGenericException("IDirectDrawSurface7::Blt: a non-specific error has occured.\n")

                DDERR_INVALIDCLIPLIST:
                    throw DirectDrawInvalidClipListException("IDirectDrawSurface7::Blt: DirectDraw does not support the provided clip list.\n")

                DDERR_INVALIDOBJECT:
                    throw DirectDrawInvalidObjectException("IDirectDrawSurface7::Blt: DirectDraw received a pointer that was an invalid DirectDraw object.\n")

                DDERR_INVALIDPARAMS:
                    throw DirectDrawInvalidParametersException("IDirectDrawSurface7::Blt: one or more of the parameters passed to the method are incorrect.\n")

                DDERR_INVALIDRECT:
                    throw DirectDrawInvalidRectException("IDirectDrawSurface7::Blt: the provided rectangle was invalid.\n")

                DDERR_NOALPHAHW:
                    throw DirectDrawNoAlphaHardwareException("IDirectDrawSurface7::Blt: no alpha acceleration hardware is present or available, causing the failure of the requested operation.\n")

                DDERR_NOBLTHW:
                    throw DirectDrawNoBlitHardwareException("IDirectDrawSurface7::Blt: no blitter hardware is present.\n")

                DDERR_NOCLIPLIST:
                    throw DirectDrawNoClipListException("IDirectDrawSurface7::Blt: no clip list is available.\n")

                DDERR_NODDROPSHW:
                    throw DirectDrawNoDDRaserOperationHardwareException("IDirectDrawSurface7::Blt: no DirectDraw raster operation (ROP) hardware is available.\n")

                DDERR_NOMIRRORHW:
                    throw DirectDrawNoMirrorHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no mirroring hardware is present or available.\n")

                DDERR_NORASTEROPHW:
                    throw DirectDrawNoRasterOperationHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no appropriate raster operation hardware is present or available.\n")

                DDERR_NOROTATIONHW:
                    throw DirectDrawNoRotationHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because no rotation hardware is present or available.\n")

                DDERR_NOSTRETCHHW:
                    throw DirectDrawNoStretchHardwareException("IDirectDrawSurface7::Blt: the operation cannot be carried out because there is no hardware support for stretching.\n")

                DDERR_NOZBUFFERHW:
                    throw DirectDrawNoZBUfferHardwareException("IDirectDrawSurface7::Blt: the hardware doesn't have Z buffer support.\n")

                DDERR_SURFACEBUSY:
                    throw DirectDrawSurfaceBusyException("IDirectDrawSurface7::Blt: the specified surface locked by another thread and access has been refused.\n")

                DDERR_SURFACELOST:
                    throw DirectDrawSurfaceLostException("IDirectDrawSurface7::Blt: access to the surface is refused because the surface memory is gone.\n")

                DDERR_UNSUPPORTED:
                    throw DirectDrawUnsupportedException("IDirectDrawSurface7::Blt: the operation isn't supported.\n")

                DDERR_WASSTILLDRAWING:
                    throw DirectDrawWasStillDrawingException("IDirectDrawSurface7::Blt: the previous blit operation that is transferring information to or from this surface is incomplete.\n")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDrawSurface7::Blt() failed.\n")
            end switch
        end if
    end function

    function void Restore() : static

        VerifyNotNull(lpDD)
        -- the return values mentioned on MSDN for RestoreAllSurfaces() are wrong.
        HRESULT result := lpDD->RestoreAllSurfaces()
        if(result != DD_OK)
            switch(result)
                    DDERR_GENERIC:
                        throw DirectDrawGenericException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_IMPLICITLYCREATED:
                        throw DirectDrawImplicitlyCreatedException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_INCOMPATIBLEPRIMARY:
                        throw DirectDrawIncompatiblePrimarySurfaceException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_INVALIDOBJECT:
                        throw DirectDrawInvalidObjectException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_INVALIDPARAMS:
                        throw DirectDrawInvalidParametersException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_NOEXCLUSIVEMODE:
                        throw DirectDrawNoExclusiveModeException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_OUTOFMEMORY:
                        throw System::OutOfMemoryException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_UNSUPPORTED:
                        throw DirectDrawUnsupportedException("IDirectDraw7::RestoreAllSurfaces: ")

                    DDERR_WRONGMODE:
                        throw DirectDrawWrongModeException("IDirectDraw7::RestoreAllSurfaces: ")

                default:
                    throw System::Runtime::InteropServices::COMException("IDirectDraw7::RestoreAllSurfaces failed.", result)
            end switch
        end if
    end function

    function void SetDisplayMode(HWND hWnd, uint width, uint height, uchar bitsPerPixel, bool fullscreen) : static

        -- Frees the surfaces on the off chance that the function is called by the user due to DirectDrawWrongModeException being 
        -- thrown (they have to be recreated if that's the case).

        if(lpDDSPrimarySurface != NULL)
            lpDDSPrimarySurface->Release()
            lpDDSPrimarySurface := NULL
        end if

        if(lpDDSSecondarySurface != NULL)
            lpDDSSecondarySurface->Release()
            lpDDSSecondarySurface := NULL

        if(lpDDClipper != NULL)
            lpDDClipper->Release()
            lpDDClipper := NULL
        end if

        try
            if fullscreen = true
                CreateFullscreenWindow(hWnd, width, height, bitsPerPixel)
            end if
        catch
            throw;
        end try-catch
    end function

    function void Shutdown() : static
        if(lpDDSPrimarySurface != NULL)
            lpDDSPrimarySurface->Release()
            lpDDSPrimarySurface := NULL
        end if

        if(lpDDSSecondarySurface != NULL)
            lpDDSSecondarySurface->Release()
            lpDDSSecondarySurface := NULL

        if(lpDDClipper != NULL)
            lpDDClipper->Release()
            lpDDClipper := NULL
        end if

        if(lpDD != NULL)
            lpDD->Release()
            lpDD := NULL
        end if
    end function

end class