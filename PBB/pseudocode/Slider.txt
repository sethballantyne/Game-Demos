class Slider inherits CotainerControl
private
    double minimumValue
    double maximumValue
    double stepValue
    double currentValue

    -- height of the slider in pixels.
    --int sliderHeight = 12;

    Lines[2] trackLines
    Lines[6] sliderLines
    function Decrement()
        if(currentValue > minimumValue)
            currentValue -= stepValue
            if(currentValue < minimumValue)
                currentValue := minimumValue
            end if

            GameOptions::SetValue(self->optionsKey, self->currentValue)
        end if
    end function

    function Increment()
        if(currentValue < maximumValue)
            currentValue += stepValue
            if(currentValue > maximumValue)
                currentValue := maximumValue
            end if

            GameOptions::SetValue(self->optionsKey, self->currentValue)
        end if
    end function
public
    constructor(int x, int y, uint width, int selectedIndex, double minimum, double maximum, double step, string optionsKey,
                MenuItemContainer parentContainer) : ContainerControl(x, y, parentContainer, selectedIndex)
         
         if(minimumValue >= maximumValue)
            throw ArgumentException("minimum is greater than or equal to maximum")
         else if(step > maximumValue)
            throw ArgumentException("step is greater than maximum")
         end if

        minimumValue := minimum
        maximumValue := maximum
        stepValue := step

        -- track
        trackLines[0] := new Line(Color::White, new Point(x, y), new Point(x + width, y))
        trackLines[1] := new Line(Color::FromArgb(0, 127, 127, 127), new Point(x, y), new Point(x + width, y))

        -- x is a placeholder, it'll be updated to the correct value when the slider is rendered.
        for(i := 0; i < sliderLines->Count; i++)
            sliderLines[i] := new Line(Colour::White, new Point(x, y - (sliderHeight / 2)), new Point(x, y + (sliderHeight / 2))
        end for
        
        -- slider shadow
        sliderLines[sliderLines->Count - 1]->Colour := Color::FromArgb(0, 83, 83, 83)
    end constructor
    
    function ReceiveSceneArgs(object[] sceneArgs)
        static bool firstRun := true
        try
            if(firstRun)
                self->currentValue := GameOptions::GetValue(self->optionsKey, self->minimumValue)
                firstRun := false
            end if
        catch
        end try
    end function

    function Render()
        Video::DrawLines(trackLines)

        double progress = currentValue / maximumvalue
        -- subtracting 3 because the slider is 6 pixels wide and currentValue is the middle of the slider.
        int pixelOffset = (int)Math::Truncate(progress * self->trackWidth) - (sliderLines->Count / 2)

        -- slider
        -- pixelOffset -= 3; 
        --for(int i := pixelOffset - 3 to pixelOffset + 2)
        --    Video::DrawLine(Color::White, self->Position->X + i, self->sliderYStartPosition, 
        --                    self->Position->X + i, self->sliderYFinishPosition)
        --end for
        --pixelOffset -= 3;
     
        for(i := 0; i < sliderLines->Count - 1; i++)
            sliderLines[i]->From->X := self->Position->X + pixelOffset
            sliderLines[i]->To->X := sliderLines[i]->From->X

            pixelOffset++
        end for

        -- slider shadow
        sliderLines[sliderLines->Count - 1]->From->X := self->Position->X + (sliderLines->Count / 2)
        sliderLines[sliderLines->Count - 1]->To->X := sliderLines[sliderLines->Count - 1]->From->X
        
        Video::DrawLines(sliderLines)
    end function

    function Update(Keys keyboardState, Mouse mouseState)
        if(keyboardState = NULL)
            throw ArgumentNullException("keyboardState")
        end if

        if(keyboardState->KeyDown(DIK_LEFT))
            self->Decrement()
        else if(keyboardState->KeyDown(DIK_RIGHT))
            self->Increment()
        end if
    end function

end class