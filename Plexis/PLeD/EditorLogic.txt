class EditorLogic
Private
	-- holds brick information read from entities.xml
	Bricks[] bricks

	Grid editorGrid
	int selectedBrick := -1
	EditingMode editingMode := EditingMode::Brush

	-- all bricks are painted to this offscreen surface and then copied.
	-- mimics double buffering.
	Bitmap bufferBitmap
	Graphics bufferBitmapGraphicsHandle
	Control renderControl
	
	ImageList brickImages

	new SolidBrush blackBrush(Color.Black)
	-- keeps track of the state of the GUI and is used to determine whether
	-- the splitcontainer needs to be displayed, so the editing controls are visible.
	-- When either File->New or File->Open are selected, guiState is set to GUIState::Editing
	-- and the splitcontainer will be visible for the life time of the programs instance.
	GUIState guiState

	bool workSaved := false

	Control[] undoGUIItems
	Control[] redoGUIItems

	new Stack undoStack
	new Stack redoStack

	function SaveAndUpdateGUI()
		XML::WriteLevel(level, bricks, filename)
		workSaved := true
		mainForm->Text := "PLeD -" + filename
	end function

	function ToggleGUIItems(Control[] guiItems, bool enabled)
		for(int i = 0, i < undoGUIItems->Length, i++)
			guiItems->Enabled := enabled
		end for
	end function

Public
	constructor EditorLogic()
		editorGrid := new Grid()

		editorGrid->CellHeight := 20
		editorGrid->CellWidth := 41
		editorGrid->GridWidth := 1024
		editorGrid->GridHeight := 480
	end constructor

	function AddBricksToListView(ImageList brickImageList, ListView listView)
		-- configuration information for the bricks has been read.
		-- Now attempt to load the first frame of each brick so it
		-- can be displayed in the editor.
		new StringBuilder sb()

		for(int i = 0, i < bricks->Length, bricks++)
			foreach(string directory in directoryList)
				sb->AppendFormat("{0}{1}{2}", directory, bricks[0]->imageName, ".bmp")
				string path = sb->ToString()
				if(File.Exists(path))
					brickImageList->Images->Add(bricks[0]->name, new Bitmap(path))

					-- using the string specified in the bricks name attribute in entities.xml
					-- as they imageList key and it just so happens it's also the label
					-- for the image in the list view.
					new ListViewItem newItem(bricks[0]->name, bricks[0]->name)
					listView.Items.Add(newItem)
					break
				end if

				sb->Clear()
			end foreach
		end for
	end function
	
	function CleanUp()
		if(gameGrid != null)
			gameGrid->Dispose()
		end if

		if(blackBrush != null)
			blackBrush->Dispose()
		end if
	end function

	function DialogResult PromptToSave()
		return MessageBox->Show("Do you want to save the changes?", "Confirmation needed",
								MessageBoxButtons->YesNoCancel, MB_ICONQUESTION)
	end function

	function bool ApplicationClosing()
		if(!workSaved)
			DialogResult dr := PromptToSave()
			switch(dr)
				DialogResult::Yes:
					dr := SaveLevelAs()
					if(dr == DialogResult::Cancel)
						return true
				DialogResult::Cancel:
					return true
			end switch
		end if

		return false
	end function

	function Initialise(PictureBox pictureBox, ImageList brickImageList, ListView listView)
		this->SetGUIState(GUIState::Default)

		this->LoadXMLData(brickImageList)
		this->AddBricksToListView(brickImageList, listView)

		this->renderControl := pictureBox
		this->renderControl->Image := bufferBitmap
		this-brickImages := brickImageList
		
	end function

	function LoadXMLData(ref ImageList imageList)
		-----------------------------------------------------------------
		-- First step: attempt load paths.xml.
		-- this file contains the locations of the resources
		-- used by the game. We need to access some of the games
		-- XML files and bitmap resources (the bricks)
		-- in order for the editor to do its job. The game is designed
		-- so certain XML and bitmap resources don't have to be in a 
		-- hardcoded, fixed location.
		-----------------------------------------------------------------
		Paths paths := XML::LoadPaths("paths.xml")

		if(paths->XMLPaths->Length = 0)
			-- throw exception
		end if

		-- enumerate all the locations we'll be searching for bitmaps.
		-- it's possible to set an attribute in the XML that specifies
		-- that the provided path and all its subdirectories should be included
		-- when searching for resources, so we have to factor this in.
		new List<string> dictionaryList

		foreach(string directory in paths->BitmapPaths)
		-- it's possible to add multiple entries of the same directory, fix if there's time.
			directory.Add(directory);

			if(directory->includeSubDirectories)
				IEnumerable<string> enumeratedDirectories := Directory.EnumerateDirectories(directory)
				if(enumeratedDirectories != null)
					dictionarylist->AddRange(enumeratedDirectories)
				end if
			end if
		end foreach
		-----------------------------------------------------------------
		-- Next step: we've located where the XML files are stored.
		-- Now we need to open entities.xml, which contains all the configuration
		-- data for the games assets. We're only interested in the bricks.
		------------------------------------------------------------------
		this->bricks := ReadBrickData(absolutePath)

		this->editorGrid->Colour := Properties->Settings->Default->GridColour
		this->editorGrid->Visible := Properties->Settings->Default->GridIsVisible
	end function

	function NewLevel()
		if(!workSaved)
			-- work hasn't been saved; ask the user if they want to save first.
			DialogResult dr := PromptToSave()
			switch(dr)
				-- Why yes, yes I would like to save. 
				DialogResult::Yes:
					-- Display the save dialog.
					DialogResult savePromptResult := SaveLevel()
					if(savePromptResult = DialogResult.Cancel)
						-- user clicked cancel on the save dialog, so fuck this. Abort, yo!
						return
					end if
				break
				DialogResult::Cancel:
					-- User clicked cancel, so abort.
					return
			end switch

			ResetState()

			editorGrid->Render(bufferBitmapGraphicsHandle)
			renderControl->Refresh()
		end if
	end function

	function OpenLevel()
		if(!workSaved)
			-- the user hasn't saved their changes. Prompt to see if they
			-- want to save their work before opening a level.
			DialogResult userResponse := PromptToSave()

			switch(userRespose)
				case DialogResult::Yes:
					-- Why yes, I would like to save.
					DialogResult saveAsDialogResponse := SaveLevel()
					if(saveAsDialogRespose == DialogResult::Cancel)
						-- user smacked cancel on the save as dialog, so cancel opening a level.
						return
					end if
					break
				case DialogResult::Cancel:
					return
			end switch
		end if

		if(openFileDialog->ShowDialog() == DialogResult::OK)
			ResetState()
			this->level := XML::ReadLevel(openFileDialog->FileName, bricks)
			mainForm->Text := "PLeD - " + openFileDialog->Filename
			filename := openFileDialog->FileName

			RenderLevel()
			
		end if
	end function

	function ResetState(Form mainForm)
		bufferBitmapGraphicsHandle->Clear(Color.Black)
		SetGUIState(GUIState::Editing)

		mainForm->Text := "PLeD"
		workSaved := true
		filename := nullptr

		level->Clear()
		undoStack->Clear()
		redoStack->Clear()
	end function

	function SaveLevel(SaveFileDialog saveFileDialog)
		DialogResult dr := DialogResult::Cancel
		if(this->filename = nullptr)
			dr := SaveFileDialog->ShowDialog()
			if(dr = DialogResult::OK)
				filename := saveFileDialog->FileName
			else
				return dr
			end if	
		end if

		SaveAndUpdateGUI()
		return dr
	end function

	function DialogResult SaveLevelAs(SaveFileDialog saveFileDialog)
		DialogResult dr := saveFileDialog->ShowDialog()
		if(dr = DialogResult::OK)
			filename := saveFileDialog->FileName
			SaveAndUpdateGUI()
		end if

		return dr
	end function

	function SetUndoGUIItems(Control[] items, ...)
		this->undoGUIItems := items;
	end function

	function SetRedoGUIItems(Control[] items, ...)
		this->redoGUIItems := items
	end function

	function PaintBrick(uint x, uint y, int index, bool refresh)
		if(index != -1)
			bufferBitmapGraphicsHandle->DrawImage(brickImages->Images[index], x, y)
		else
			bufferBitmapGraphicsHandle->FillRectangle(blackBrush, x, y, bricks[0]->brickWidth, brickHeight)
		end if

		-- do we need to refresh the image now we've painted?
		if(refresh)
			if(editorGrid->Visible)
				editorGrid->Draw(bufferBitmapGraphicsHandle)
			end if

			renderControl->Refresh()
		end if
	end function

	function RenderLevel()
		bufferBitmapGraphicsHandle->Clear(Color.Black)

		for(uint i := 0, i < level->Width, i++)
			for(int j := 0, j < level->Height, j++)
				int value := level->GetElement(i, j)
				if(value != -1)
					PaintBrick(i * bricks[0]->frameWidth, bricks[0]->frameHeight)
				end if
			end for
		end for

		editorGrid->Render(bufferBitmapGraphicsHandle)
		renderControl->Refresh()
	end function

	function SetSelectedBrick(int index)
		this->selectedbrick := index
	end function

	function SetEditingMode(EditingMode editingMode)
		this->editingMode := editingMode
		if(this->editingMode = Eraser)
			this->mainForm->Cursor := eraserCursor
			this->selectedBrick := -1
			-- also disable brush GUI items
		else
			this->mainForm->Cursor := Cursors::Default
			-- disable eraser gui items
		end if
	end function

	function PictureBoxMouseDown(ListView listView)
		-- use the original
	end function

	function PictureBoxMouseOver(ListView listView)
	-- use original
	end function

	function PictureBoxMOuseUp()
		-- use original
	end function

	function SetGUIState(GuiState state)
		switch(state)
			GuiState::Default

				-- hide the brush panel and level renderer.
				splitContainer.Visible := false

			    -----------------------------------------
				-- FILE MENU
				-----------------------------------------
				saveLevelToolStripButton.Enabled := false
				saveToolStripMenuItem.Enabled := false
				saveAsToolStripMenuItem.Enabled := false

				previewLevelToolStripButton.Enabled := false
				previewToolStripMenuItem.Enabled := false

				------------------------------------------
				-- EDIT MENU
				------------------------------------------
				undoToolStripMenuItem.Enabled := false
				undoToolStripButton.Enabled := false
				redoToolStripMenuItem.Enabled := false
				redoToolStripButton.Enabled := false

				-------------------------------------------
				-- VIEW MENU
				-------------------------------------------
				toggleGridToolStripButton.Enabled := false
				toggleGridToolStripMenuItem.Enabled := false

				-------------------------------------------
				-- TOOLS MENU
				-------------------------------------------
				eraserToolStripMenuItem.Enabled := false
				eraserToolStripButton.Enabled := false

				brushToolStripMenuItem.Enabled := false
				brushToolStripButton.Enabled := false

			GuiState::Editing
				splitContainer.Visible := true

				-----------------------------------------
				-- FILE MENU
				-----------------------------------------
				saveLevelToolStripButton.Enabled := true
				saveToolStripMenuItem.Enabled := true
				saveAsToolStripMenuItem.Enabled := true

				previewLevelToolStripButton.Enabled := true
				previewToolStripMenuItem.Enabled := true

				-------------------------------------------
				-- VIEW MENU
				-------------------------------------------
				toggleGridToolStripButton.Enabled := true
				toggleGridToolStripMenuItem.Enabled := true

				-------------------------------------------
				-- TOOLS MENU
				-------------------------------------------
				eraserToolStripMenuItem.Enabled := true
				eraserToolStripButton.Enabled := true

				brushToolStripMenuItem.Enabled := true
				brushToolStripButton.Enabled := true
		end switch

	end function

	function ToggleGrid()
		this->editorGrid->Visible := !this->editorGrid->Visible

		-- Update the GUI items. You'll need to create accessors same as the Undo/Redo ones.
		
		Settings->Default->EnableGrid := this->editorGrid->Visible
        Settings->Default->Save()

		RenderLevel()
	end function

	function SetGridColour(ColorDialog colourDialog)
		if(colourDialog->ShowDialog())
			-- same as the original
		end if
	end function

	function Undo()
		Tile[] bricksPoppedOffUndoStack := undoStack->Pop()
		new List<Tile> temp 

		foreach(Tile tile in bricksPoppedOffUndoStack)
			-- converting from screen to tile coordinates
			uint x := tile->X / bricks[0]->width
			uint y := tile->Y / bricks[0]->height

			-- take each brick we're about the paint over and stick them in a buffer 
            -- which will be passed to the redo stack once painting is finished. 
            -- short brickIndex = map[tileCoordX, tileCoordY];
			int brickIndex := level->GetElement(x, y)
			temp->Add(new Tile(tile->X, tile->Y, brickIndex))

			level->SetBrick(x, y, tile->index)
			PaintBrick(tile->x, tile->y, tile->index, false)
		end foreach

		redoStack->Push(temp->ToArray())
		grid->Render(bufferBitmapGraphicsHandle)
		renderControl->Refresh()

		if(undoStack->Count = 0)
			ToggleGUIItems(undoGUIItems, false)
		end if

		ToggleGUIItems(redoGUIItems, true)
	end function

	function Redo()
		-- same as Redo() in original editor, with the exception
		-- of ToggleGUIItems() being used to toggle undo and redo menu items
	end function

end class